// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import javax.lang.model.util.ElementScanner6;

import com.ctre.phoenix.motorcontrol.ControlMode;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.DriveTrain;
import frc.robot.subsystems.Imu;
import frc.robot.Constants;
import frc.robot.commands.TurnAngleIMU;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class FtcGryoTurn extends CommandBase {

    private double m_Speed;
    private double m_Heading;
    private double m_Distance;
    private double m_MoveCount;
    private boolean Left;
    private boolean Right;
    private double newLeftTarget;
    private double newRightTarget;
    private double speed;
    private double count;
   
    static final double DRIVE_SPEED = 0.7;     // Nominal speed for better accuracy.
    static final double TURN_SPEED = 0.5;     // Nominal half speed for better accuracy.
    static final double HEADING_THRESHOLD = 3.5;      // As tight as we can make it with an integer gyro
   // static final double P_TURN_COEFF = 0.07;     // Larger is more responsive, but also less stable 0.1
    static final double P_TURN_COEFF = 0.11;     // Larger is more responsive, but also less stable 0.1
    //static final double P_TURN_COEFF = 0.6;     // Larger is more responsive, but also less stable 0.1
    static final double P_DRIVE_COEFF = 0.015;     // Larger is more responsive, but also less stable 0.15
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveTrain m_driveTrain;
        //private final Imu m_imu;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    public double getAdjustedYaw()
    {
        //return -m_imu.getImu().getYaw();
        return -m_driveTrain.getImu().getYaw();
    }
    public double getError(double targetAngle)
    {

        double robotError;
           
        
        robotError = targetAngle - getAdjustedYaw(); // the - on the target determines the direction

        while (robotError > 180) robotError -= 360;
        while (robotError <= -180) robotError += 360;
      
        return robotError;
    }

    public double getSteer(double error, double PCoeff) {
        return DriveTrain.clip(error * PCoeff, -1, 1);

    }


    public FtcGryoTurn(DriveTrain driveTrain, double Speed, double Heading) 
    {

        m_Heading = Heading;
        m_Speed = Speed;
       // m_Distance = Distance; 
        
        
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_driveTrain = driveTrain;
       // m_imu = imu;
        addRequirements(m_driveTrain);
       // addRequirements(m_imu);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        count = 0;

        m_driveTrain.getDifferentialDrive().setSafetyEnabled(false);

      //  m_driveTrain.SetPercentOutput(1, Constants.kTimeoutMs); //max possible speed
        
    
    }





    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {

    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_driveTrain.getDifferentialDrive().tankDrive(0,0);
        
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished()
     {
         //return false;
         final double deadband = 400;
         SmartDashboard.putBoolean("IsLeftClose", m_driveTrain.IsLeftClose(deadband));
         SmartDashboard.putBoolean("IsRightClose", m_driveTrain.IsRightClose(deadband));

    
         // return (m_driveTrain.IsLeftClose(deadband) &&  m_driveTrain.IsRightClose(deadband));
        if (onHeading(m_Speed, m_Heading, P_TURN_COEFF))
          count++;
        else
          count = 0;
        
        return (count > 20);
   //      return true;

     // else
      //  return false;
            
      
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

    
/**
*  Method to spin on central axis to point in a new direction.
*  Move will stop if either of these conditions occur:
*  1) Move gets to the heading (angle)
*  2) Driver stops the opmode running.
*
* @param speed Desired speed of turn.
* @param angle      Absolute Angle (in Degrees) relative to last gyro reset.
*                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.
*                   If a relative angle is required, add/subtract from current heading.
*/
/*
public void gyroTurn (  double speed, double angle) {

   // ElapsedTime elapsedTime = new ElapsedTime();
 //   elapsedTime.reset();
// keep looping while we are still active, and not on heading.
    while (!onHeading(speed, angle, P_TURN_COEFF)) {
        // Update telemetry & Allow time for other processes to run.
        //robot_.OpMode_.telemetry.update();
    }
}
*/
/**
 *  Method to obtain & hold a heading for a finite amount of time
 *  Move will stop once the requested time has elapsed
 *
 * @param speed      Desired speed of turn.
 * @param angle      Absolute Angle (in Degrees) relative to last gyro reset.
 *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.
 *                   If a relative angle is required, add/subtract from current heading.
 * @param holdTime   Length of time (in seconds) to hold the specified heading.
 *                   */
/*
public void gyroHold( double speed, double angle, double holdTime) {

    ElapsedTime holdTimer = new ElapsedTime();

// keep looping while we have time remaining.
    holdTimer.reset();
    while (robot_.OpMode_.opModeIsActive() && (holdTimer.time() < holdTime)) {
        // Update telemetry & Allow time for other processes to run.
        onHeading(speed, angle, robot_.P_TURN_COEFF);
        robot_.OpMode_.telemetry.update();
    }

// Stop all motion;
    robot_.leftFront.setPower(0);
    robot_.rightFront.setPower(0);
    robot_.leftBack.setPower(0);
    robot_.leftBack.setPower(0);
}
*/
/*
 * Perform one cycle of closed loop heading control.
 *
 * @param speed     Desired speed of turn.
 * @param angle     Absolute Angle (in Degrees) relative to last gyro reset.
 *                  0 = fwd. +ve is CCW from fwd. -ve is CW from forward.
 *                  If a relative angle is required, add/subtract from current heading.
 * @param PCoeff    Proportional Gain coefficient
 * @return
 */
boolean onHeading(double speed, double angle, double PCoeff) {
    double   error ;
    double   steer ;
    boolean  onTarget = false ;
    double leftFrontSpeed;
    double rightFrontSpeed;
    double leftBackSpeed;
    double rightBackSpeed;


// determine turn power based on +/- error
    error = getError(angle);
    System.out.println("Valleyx error: " + error);

    if (Math.abs(error) <= HEADING_THRESHOLD) {
        steer= 0;
        leftBackSpeed  = 0.0;
        rightBackSpeed = 0.0;
        leftFrontSpeed  = 0.0;
        rightFrontSpeed = 0.0;
        onTarget = true;
    }
    else {
        steer = getSteer(error, PCoeff);
        /*
        rightBackSpeed  = speed * steer;
        rightFrontSpeed  = speed * steer; // no -
        leftBackSpeed   = -rightBackSpeed; // yep -
        leftFrontSpeed = -rightFrontSpeed;
         */
        rightBackSpeed  = speed * -steer;
        rightFrontSpeed  = speed * -steer; //
        leftBackSpeed   = -rightBackSpeed; //
        leftFrontSpeed = -rightFrontSpeed;
    }

// Send desired speeds to motors.
    m_driveTrain.getDifferentialDrive().tankDrive(leftFrontSpeed, rightBackSpeed);


// Display it for the driver.
/*
telemetry.addData("Target", "%5.2f", angle);
telemetry.addData("Err/St", "%5.2f/%5.2f", error, steer);
telemetry.addData("Speed.", "%5.2f:%5.2f:%5.2f:%5.2f", leftFrontSpeed, rightFrontSpeed, leftBackSpeed, rightBackSpeed);
 */

    //robot_.OpMode_.telemetry.update();
    return onTarget;


}





}
